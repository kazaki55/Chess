<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Math Rush</title>
<style>
  :root{
    --bg1: #0f172a; --bg2:#071034; --card:#0b1220;
    --accent:#ffd166; --good:#22c55e; --bad:#ff6b6b; --muted:#9fb8df;
  }
  html,body{height:100%;margin:0;font-family:Inter,Segoe UI,Arial,sans-serif;background:
    radial-gradient(1200px 600px at 10% 10%, rgba(120,87,224,0.12), transparent),
    linear-gradient(180deg,var(--bg1),var(--bg2));color:#e6eef8}
  .wrap{max-width:980px;margin:12px auto;padding:12px;display:flex;flex-direction:column;gap:12px}
  header{display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap}
  h1{margin:0;font-size:20px}
  .controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .btn{background:linear-gradient(180deg,#183b71,#07214a);border:0;padding:8px 12px;border-radius:10px;color:#fff;font-weight:700;cursor:pointer}
  .chip{background:rgba(255,255,255,0.04);padding:8px 10px;border-radius:10px;border:1px solid rgba(255,255,255,0.03)}
  .topbar{display:flex;gap:8px;align-items:center}
  main{display:flex;gap:12px;flex-wrap:wrap}
  .panel{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));padding:12px;border-radius:12px;border:1px solid rgba(255,255,255,0.03);box-shadow:0 6px 18px rgba(2,6,23,0.6)}
  .left{flex:1;min-width:260px;display:flex;flex-direction:column;gap:12px}
  .right{width:320px;min-width:220px}
  #arena{height:420px;background:linear-gradient(180deg,#061428,#08203b);border-radius:10px;position:relative;overflow:hidden;border:1px solid rgba(255,255,255,0.04)}
  .problem{position:absolute;left:50%;transform:translateX(-50%);padding:10px 14px;border-radius:12px;background:linear-gradient(180deg,#fefefe,#dfeffb);color:#05202e;font-weight:800;box-shadow:0 8px 18px rgba(2,6,23,0.55);font-size:18px;white-space:nowrap}
  .hud{display:flex;justify-content:space-between;align-items:center;gap:8px}
  .big{font-size:24px;font-weight:800}
  #inputRow{display:flex;gap:8px;margin-top:8px}
  #answerInput{flex:1;padding:10px;border-radius:10px;border:0;font-size:18px}
  .danger{background:linear-gradient(90deg,#ff6b6b,#ff8f66);color:#fff}
  .good{background:linear-gradient(90deg,#22c55e,#74f59a);color:#012a14}
  .difficulty{display:flex;gap:6px}
  .difficulty .btn{padding:6px 8px;font-weight:700;background:transparent;border:1px solid rgba(255,255,255,0.06)}
  #footer{font-size:12px;color:var(--muted);text-align:center;margin-top:6px}
  /* mobile layout adjustments */
  @media (max-width:720px){
    .right{width:100%;min-width:unset}
    #arena{height:360px}
    .problem{font-size:16px;padding:8px}
  }
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>Math Rush</h1>
        <div style="font-size:12px;color:var(--muted)">Solve falling problems before they hit the bottom</div>
      </div>
      <div class="topbar">
        <div class="chip">Score: <span id="score">0</span></div>
        <div class="chip">Lives: <span id="lives">3</span></div>
        <div class="chip">Level: <span id="level">1</span></div>
        <button id="pauseBtn" class="btn">Pause</button>
        <button id="restartBtn" class="btn">Restart</button>
      </div>
    </header>

    <main>
      <div class="left panel">
        <div id="arena" aria-live="polite"></div>

        <div id="inputRow">
          <input id="answerInput" inputmode="numeric" autocomplete="off" placeholder="Type answer" />
          <button id="submitBtn" class="btn">Submit</button>
        </div>

        <div style="display:flex;justify-content:space-between;align-items:center;margin-top:8px">
          <div class="difficulty">
            <button data-diff="easy" class="btn">Easy</button>
            <button data-diff="normal" class="btn">Normal</button>
            <button data-diff="hard" class="btn">Hard</button>
          </div>
          <div style="font-size:13px;color:var(--muted)">Best: <span id="best">0</span></div>
        </div>
      </div>

      <div class="right panel">
        <div class="hud">
          <div>
            <div class="big" id="nextMsg">Next:</div>
            <div style="font-size:13px;color:var(--muted)">Problems fall faster each level</div>
          </div>
        </div>

        <hr style="border:none;height:10px">

        <div style="display:flex;flex-direction:column;gap:8px">
          <div class="chip">Time: <span id="time">0.0</span>s</div>
          <div class="chip">Active Problems: <span id="activeCount">0</span></div>
          <div class="chip">Difficulty: <span id="diffLabel">easy</span></div>
        </div>

        <div style="margin-top:12px">
          <div style="font-size:14px;font-weight:700;margin-bottom:6px">How to Play</div>
          <ol style="padding-left:18px;color:var(--muted);margin:0">
            <li>Solve the expression shown in a falling card</li>
            <li>Type answer and press Submit or tap the card</li>
            <li>Wrong or missed problems cost a life</li>
            <li>Reach higher levels for faster fall speed</li>
          </ol>
        </div>
      </div>
    </main>

    <div id="footer">Made with ❤️ — Math Rush · Local game for web & mobile</div>
  </div>

<script>
(() => {
  // CONFIG
  const config = {
    spawnInterval: 1200,   // base ms between spawns (scaled by difficulty)
    baseSpeed: 40,         // px per second at level 1
    speedGainPerLevel: 12, // px/sec added each level
    maxActive: 6,
    lives: 3,
    levelUpEvery: 10, // points needed to increase level
    ops: { easy:['+','-'], normal:['+','-','*'], hard:['+','-','*','/'] }
  };

  // STATE
  let score = 0, lives = config.lives, level = 1, time = 0;
  let activeProblems = [], spawnTimer = 0, lastTime = null, paused = false;
  let difficulty = 'easy';
  let spawnInterval = config.spawnInterval;
  let arenaEl = document.getElementById('arena');
  const inputEl = document.getElementById('answerInput');
  const submitBtn = document.getElementById('submitBtn');
  const scoreEl = document.getElementById('score');
  const livesEl = document.getElementById('lives');
  const levelEl = document.getElementById('level');
  const timeEl = document.getElementById('time');
  const activeCountEl = document.getElementById('activeCount');
  const diffLabel = document.getElementById('diffLabel');
  const bestEl = document.getElementById('best');
  const pauseBtn = document.getElementById('pauseBtn');

  // SOUND (WebAudio)
  const AudioCtx = window.AudioContext || window.webkitAudioContext;
  let audioCtx;
  function ensureAudio(){
    if(!audioCtx) audioCtx = new AudioCtx();
  }
  function playBeep(freq, len=0.08, type='sine', vol=0.12){
    try{
      ensureAudio();
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = type; o.frequency.value = freq;
      g.gain.value = vol;
      o.connect(g); g.connect(audioCtx.destination);
      o.start();
      g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + len);
      o.stop(audioCtx.currentTime + len + 0.02);
    }catch(e){}
  }
  function playCorrect(){ playBeep(880,0.12,'sine',0.14); }
  function playWrong(){ playBeep(220,0.22,'triangle',0.18); }
  function playMiss(){ playBeep(160,0.28,'sawtooth',0.22); }
  function playLevelUp(){ playBeep(1200,0.12,'triangle',0.2); setTimeout(()=>playBeep(1500,0.12,'triangle',0.2),130); }

  // STORAGE
  const BEST_KEY = 'mathrush_best_' + location.pathname;
  bestEl.textContent = localStorage.getItem(BEST_KEY) || '0';

  // UI hook-ups
  document.querySelectorAll('[data-diff]').forEach(b=>{
    b.addEventListener('click', ()=>{ difficulty = b.dataset.diff; diffLabel.textContent = difficulty; resetGame(); });
  });
  submitBtn.addEventListener('click', submitAnswer);
  inputEl.addEventListener('keydown', (e)=>{ if(e.key === 'Enter') submitAnswer(); });
  document.getElementById('restartBtn').addEventListener('click', resetGame);
  pauseBtn.addEventListener('click', ()=>{ paused = !paused; pauseBtn.textContent = paused ? 'Resume' : 'Pause'; if(!paused){ lastTime = performance.now(); tick(lastTime); } });

  // helper: random integer [min,max]
  function ri(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }

  // create a problem object and DOM element
  function makeProblem(){
    const ops = config.ops[difficulty];
    const op = ops[ri(0, ops.length-1)];
    let a,b,ans,display;
    if(op === '+'){ a=ri(1,20); b=ri(1,20); ans = a+b; display = `${a} + ${b}`; }
    else if(op === '-'){ a=ri(0,30); b=ri(0,a); ans = a-b; display = `${a} - ${b}`; }
    else if(op === '*'){ a=ri(2,12); b=ri(2,10); ans = a*b; display = `${a} × ${b}`; }
    else if(op === '/'){ b = ri(2,10); ans = ri(2,12); a = b*ans; display = `${a} ÷ ${b}`; }
    // difficulty variations: sometimes include negative or bigger numbers on higher diffs
    if(difficulty === 'hard' && Math.random() < 0.15){
      // swap to larger values occasionally
      a *= ri(1,3); ans = eval(display.replace('×','*').replace('÷','/')); display = display;
    }

    // DOM
    const el = document.createElement('div');
    el.className = 'problem';
    el.textContent = display;
    arenaEl.appendChild(el);

    // position: random x inside arena with margin
    const arenaRect = arenaEl.getBoundingClientRect();
    const margin = 32;
    const x = ri(margin, Math.max(margin, Math.floor(arenaRect.width - margin)));
    el.style.left = x + 'px';
    el.style.top = '-60px';

    return { el, display, ans, x, y:-60, speed: getSpeed(), id: Date.now() + Math.random() };
  }

  function getSpeed(){
    // px per second
    return config.baseSpeed + (level-1) * config.speedGainPerLevel;
  }

  // spawn logic
  function spawnProblem(){
    if(activeProblems.length >= config.maxActive) return;
    const p = makeProblem();
    activeProblems.push(p);
    updateHUD();
  }

  // updates DOM HUD
  function updateHUD(){
    scoreEl.textContent = score;
    livesEl.textContent = lives;
    levelEl.textContent = level;
    activeCountEl.textContent = activeProblems.length;
    timeEl.textContent = (time/1000).toFixed(1);
  }

  // Game tick
  function tick(now){
    if(paused) return;
    if(!lastTime) lastTime = now;
    const dt = Math.min(100, now - lastTime); // ms
    lastTime = now;
    time += dt;
    // spawn timer
    spawnTimer += dt;
    // spawn interval scales with difficulty and level
    const diffScale = difficulty === 'easy' ? 1.1 : difficulty === 'normal' ? 1.0 : 0.85;
    const currentSpawnInterval = spawnInterval * diffScale * Math.max(0.55, 1 - (level-1)*0.04);
    if(spawnTimer >= currentSpawnInterval){
      spawnTimer = 0;
      spawnProblem();
    }

    // move problems
    for(let i = activeProblems.length-1; i>=0; i--){
      const p = activeProblems[i];
      const dy = p.speed * (dt/1000);
      p.y += dy;
      p.el.style.top = p.y + 'px';
      // if bottom reached
      if(p.y > arenaEl.clientHeight - 20){
        // missed
        arenaEl.removeChild(p.el);
        activeProblems.splice(i,1);
        lives--;
        playMiss();
        if(lives <= 0){ gameOver(); return; }
      }
    }

    updateHUD();
    requestAnimationFrame(tick);
  }

  // submit answer: match any active problem with same answer (closest one prioritized)
  function submitAnswer(){
    if(paused) return;
    const raw = inputEl.value.trim();
    if(raw === '') return;
    // accept integer answers only for now
    const val = Number(raw);
    if(Number.isNaN(val)){ inputEl.value=''; return; }
    // find matching problems
    // prefer the smallest vertical position (closest to bottom) if multiple
    let candidates = activeProblems.filter(p => Math.round(p.ans) === Math.round(val));
    if(candidates.length === 0){
      // wrong
      score = Math.max(0, score - 1);
      playWrong();
      inputEl.value='';
      updateHUD();
      return;
    }
    // choose candidate with largest y (closest to bottom)
    candidates.sort((a,b)=> b.y - a.y);
    const hit = candidates[0];
    // remove it
    try{ arenaEl.removeChild(hit.el); }catch(e){}
    const idx = activeProblems.findIndex(x=>x.id === hit.id);
    if(idx >= 0) activeProblems.splice(idx,1);

    // score and possibly level up
    score += 1;
    playCorrect();

    if(score > Number(localStorage.getItem(BEST_KEY) || 0)){
      localStorage.setItem(BEST_KEY, score);
      bestEl.textContent = score;
    }

    // level up every levelUpEvery points
    if(score > 0 && score % config.levelUpEvery === 0){
      level++;
      playLevelUp();
      // increase speed of existing problems
      activeProblems.forEach(p => p.speed = getSpeed());
    }

    inputEl.value='';
    updateHUD();
  }

  function gameOver(){
    paused = true;
    // clear problems visually
    activeProblems.forEach(p=>{ try{ arenaEl.removeChild(p.el);}catch(e){} });
    activeProblems = [];
    updateHUD();
    // show message
    const msg = document.createElement('div');
    msg.className = 'problem';
    msg.style.left = '50%'; msg.style.transform = 'translateX(-50%)';
    msg.style.top = '40%';
    msg.style.background = 'linear-gradient(90deg,#ffb4b4,#ff7a7a)';
    msg.style.color = '#3d0303';
    msg.style.fontSize = '22px';
    msg.textContent = `Game Over — Score: ${score}`;
    arenaEl.appendChild(msg);
    playWrong();
    // offer restart after a short delay
    setTimeout(()=>{ msg.textContent += ' · Press Restart'; },800);
  }

  // reset / restart
  function resetGame(){
    // clear arena
    activeProblems.forEach(p=>{ try{ arenaEl.removeChild(p.el);}catch(e){} });
    activeProblems = [];
    score = 0; lives = config.lives; level = 1; time = 0;
    spawnTimer = 0; lastTime = null; paused = false;
    diffLabel.textContent = difficulty;
    // set spawnInterval base per difficulty
    spawnInterval = { easy:1400, normal:1200, hard:900 }[difficulty] || config.spawnInterval;
    // start ticking
    updateHUD();
    // remove any leftover "Game Over" messages
    Array.from(arenaEl.querySelectorAll('.problem')).forEach(el=>{
      // if it looks like a big msg (no arithmetic operators), remove
      if(!/[+\-×÷*\/]/.test(el.textContent)) try{ arenaEl.removeChild(el); }catch(e){}
    });
    if(!lastTime) lastTime = performance.now();
    requestAnimationFrame(tick);
  }

  // click on problem to auto-fill answer and submit (nice for touch)
  arenaEl.addEventListener('click', (ev)=>{
    if(paused) return;
    const target = ev.target.closest('.problem');
    if(!target) return;
    // find matching active problem by element
    const p = activeProblems.find(pp => pp.el === target);
    if(!p) return;
    inputEl.value = Math.round(p.ans);
    submitAnswer();
  });

  // init
  diffLabel.textContent = difficulty;
  bestEl.textContent = localStorage.getItem(BEST_KEY) || '0';
  resetGame();
  // focus input on load for desktop
  setTimeout(()=>{ inputEl.focus(); },400);

})();
</script>
</body>
</html>
